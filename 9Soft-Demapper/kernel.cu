  void Soft_Demapper_QPSK(uint8_t *out0, uint8_t *out1, uint8_t *out2, uint8_t *out3, const float *input_data_re, const float *input_data_im, const unsigned int sizeData)
{
    int i = threadIdx.x + blockDim.x*blockIdx.x;
    while (i < sizeData)
    {
        uint8_t tmp, tmp_remap;
        tmp = input_data_re[i] > 0 ? (input_data_im[i] > 0 ? 0 : 3) : (input_data_im[i] > 0 ? 1 : 2);
        tmp_remap = c_CustomSymbolMapping_QPSK[tmp + 4];
        out0[2 * i + 0] = tmp_remap / 2;
        out0[2 * i + 1] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_QPSK[tmp + 3];
        out1[2 * i + 0] = tmp_remap / 2;
        out1[2 * i + 1] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_QPSK[tmp + 2];
        out2[2 * i + 0] = tmp_remap / 2;
        out2[2 * i + 1] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_QPSK[tmp + 1];
        out3[2 * i + 0] = tmp_remap / 2;
        out3[2 * i + 1] = tmp_remap % 2;

        i += blockDim.x*gridDim.x;
    }
}


__global__
    void Soft_Demapper_8PSK(uint8_t *out0, uint8_t *out1, uint8_t *out2, uint8_t *out3, uint8_t *out4, uint8_t *out5, uint8_t *out6, uint8_t *out7, float *input_data_re, float *input_data_im, const unsigned int sizeData)
{

    int i = threadIdx.x + blockDim.x*blockIdx.x;
//    if(i == 0)
//        for(int tmp{}; tmp < 20; tmp++)
//            printf("%f + j%f \n", input_data_re[tmp + 60], input_data_im[tmp + 60]);
    while (i < sizeData)
    {
        float val_re = input_data_re[i] * 0.923879532511287 - input_data_im[i] * 0.382683432365090;
        float val_im = input_data_re[i] * 0.382683432365090 + input_data_im[i] * 0.923879532511287;

        uint8_t tmp, tmp_remap;
        tmp = val_re > 0 ? (val_im > 0 ? (val_re > val_im ? 0 : 1) : (val_re > -val_im ? 7 : 6)) : (val_im > 0 ? (-val_re > val_im ? 3 : 2) : (-val_re > -val_im ? 4 : 5));

        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 8];
        out0[3 * i + 0] = tmp_remap / 4;
        out0[3 * i + 1] = (tmp_remap % 4) / 2;
        out0[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 7];
        out1[3 * i + 0] = tmp_remap / 4;
        out1[3 * i + 1] = (tmp_remap % 4) / 2;
        out1[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 6];
        out2[3 * i + 0] = tmp_remap / 4;
        out2[3 * i + 1] = (tmp_remap % 4) / 2;
        out2[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 5];
        out3[3 * i + 0] = tmp_remap / 4;
        out3[3 * i + 1] = (tmp_remap % 4) / 2;
        out3[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 4];
        out4[3 * i + 0] = tmp_remap / 4;
        out4[3 * i + 1] = (tmp_remap % 4) / 2;
        out4[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 3];
        out5[3 * i + 0] = tmp_remap / 4;
        out5[3 * i + 1] = (tmp_remap % 4) / 2;
        out5[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 2];
        out6[3 * i + 0] = tmp_remap / 4;
        out6[3 * i + 1] = (tmp_remap % 4) / 2;
        out6[3 * i + 2] = tmp_remap % 2;
        tmp_remap = c_CustomSymbolMapping_8PSK[tmp + 1];
        out7[3 * i + 0] = tmp_remap / 4;
        out7[3 * i + 1] = (tmp_remap % 4) / 2;
        out7[3 * i + 2] = tmp_remap % 2;
        //if (i == 0)
        //	printf("%u, %u, %u , temp = %u \n", out0[3 * i + 0], out0[3 * i + 1], out0[3 * i + 2], tmp);
        i += blockDim.x*gridDim.x;
    }
}

__global__
    void setModulationSymb(float* modulation_symb_re, float* modulation_symb_im, int* type, float* codeRate)
{
    int i{ threadIdx.x };
    //if (i == 0)
    //	printf("modOrder = %i \n", type[0]);
    if (type[0] == 2) //QPSK
    {
        float temp_re[4] = { 0.707107, 0.707107, -0.707107,-0.707107 };
        float temp_im[4] = { 0.707107, -0.707107, 0.707107,-0.707107 };
        //for (int i = 0; i < 4; i++)
        if (i < 4)
        {
            modulation_symb_re[i] = temp_re[i];
            modulation_symb_im[i] = temp_im[i];
        }
    }
    else if (type[0] == 3) //8PSK
    {
        float temp_re[8] = { 0.707107,1.000000,-1.000000,-0.707107,0.000000,0.707107,-0.707107,0.000000 };
        float temp_im[8] = { 0.707107,0.000000,0.000000,-0.707107,1.000000,-0.707107,0.707107,-1.000000 };
        //for (int i = 0; i < 8; i++)
        if (i < 8)
        {
            modulation_symb_re[i] = temp_re[i];
            modulation_symb_im[i] = temp_im[i];
        }
    }
    else if (type[0] == 4) //16APSK
    {
        if (codeRate[0] == 2.f / 3) //	2/3
        {
            float temp_re[16] = { 0.707106781186548,0.707106781186547,-0.707106781186547,-0.707106781186548,0.965925826289068,0.965925826289068,-0.965925826289068,-0.965925826289068,0.258819045102521,0.258819045102520,-0.258819045102521,-0.258819045102522,0.224478343233825,0.224478343233825,-0.224478343233825,-0.224478343233825 };
            float temp_im[16] = { 0.707106781186547,-0.707106781186548, 0.707106781186548,-0.707106781186547, 0.258819045102521,-0.258819045102522, 0.258819045102521,-0.258819045102521, 0.965925826289068,-0.965925826289068, 0.965925826289068,-0.965925826289068, 0.224478343233825,-0.224478343233825, 0.224478343233825,-0.224478343233825 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 3.f / 4) //	3/4
        {
            float temp_re[16] = { 0.707106781186548, 0.707106781186547, -0.707106781186547, -0.707106781186548, 0.965925826289068, 0.965925826289068, -0.965925826289068, -0.965925826289068, 0.258819045102521, 0.258819045102520,-0.258819045102521,-0.258819045102522, 0.248107642521596, 0.248107642521596,-0.248107642521596,-0.248107642521596 };
            float temp_im[16] = { 0.707106781186547,  -0.707106781186548,   0.707106781186548,  -0.707106781186547,   0.258819045102521,  -0.258819045102522,   0.258819045102521,  -0.258819045102521,   0.965925826289068,  -0.965925826289068,   0.965925826289068,  -0.965925826289068,   0.248107642521596,  -0.248107642521596,   0.248107642521596,  -0.248107642521596 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 4.f / 5) //	4/5
        {
            float temp_re[16] = { 0.707106781186548,   0.707106781186547,  -0.707106781186547,  -0.707106781186548,   0.965925826289068,   0.965925826289068,  -0.965925826289068,  -0.965925826289068,   0.258819045102521,   0.258819045102520,  -0.258819045102521,  -0.258819045102522,   0.257129738613290,   0.257129738613290,  -0.257129738613290,  -0.257129738613290 };
            float temp_im[16] = { 0.707106781186547,  -0.707106781186548,   0.707106781186548,  -0.707106781186547,   0.258819045102521,  -0.258819045102522,   0.258819045102521,  -0.258819045102521,   0.965925826289068,  -0.965925826289068,   0.965925826289068,  -0.965925826289068,   0.257129738613290,  -0.257129738613290,   0.257129738613290,  -0.257129738613290 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 5.f / 6) //	5/6
        {
            float temp_re[16] = { 0.707106781186548,   0.707106781186547,  -0.707106781186547,  -0.707106781186548,   0.965925826289068,   0.965925826289068,  -0.965925826289068,  -0.965925826289068,   0.258819045102521,   0.258819045102520,  -0.258819045102521,  -0.258819045102522,   0.261891400439462,   0.261891400439462,  -0.261891400439462,  -0.261891400439462 };
            float temp_im[16] = { 0.707106781186547,  -0.707106781186548,   0.707106781186548,  -0.707106781186547,   0.258819045102521,  -0.258819045102522,   0.258819045102521,  -0.258819045102521,   0.965925826289068,  -0.965925826289068,   0.965925826289068,  -0.965925826289068,   0.261891400439462,  -0.261891400439462,   0.261891400439462,  -0.261891400439462 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 8.f / 9) //	8/9
        {
            float temp_re[16] = { 0.707106781186548,   0.707106781186547,  -0.707106781186547,  -0.707106781186548,   0.965925826289068,   0.965925826289068,  -0.965925826289068,  -0.965925826289068,   0.258819045102521,   0.258819045102520,  -0.258819045102521,  -0.258819045102522,   0.271964146610211,   0.271964146610211,  -0.271964146610211,  -0.271964146610211 };
            float temp_im[16] = { 0.707106781186547,  -0.707106781186548,   0.707106781186548,  -0.707106781186547,   0.258819045102521,  -0.258819045102522,   0.258819045102521,  -0.258819045102521,   0.965925826289068,  -0.965925826289068,   0.965925826289068,  -0.965925826289068,   0.271964146610211,  -0.271964146610211,   0.271964146610211,  -0.271964146610211 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 9.f / 10) //	9/10
        {
            float temp_re[16] = { 0.707106781186548,   0.707106781186547,  -0.707106781186547,  -0.707106781186548,   0.965925826289068,   0.965925826289068,  -0.965925826289068,  -0.965925826289068,   0.258819045102521,   0.258819045102520,  -0.258819045102521,  -0.258819045102522,   0.275138825364415,   0.275138825364415,  -0.275138825364415,  -0.275138825364415 };
            float temp_im[16] = { 0.707106781186547,  -0.707106781186548,   0.707106781186548,  -0.707106781186547,   0.258819045102521,  -0.258819045102522,   0.258819045102521,  -0.258819045102521,   0.965925826289068,  -0.965925826289068,   0.965925826289068,  -0.965925826289068,   0.275138825364415,  -0.275138825364415,   0.275138825364415,  -0.275138825364415 };
            //for (int i = 0; i < 16; i++)
            if (i < 16)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else
            if(i == 0)
            printf("invalid codeRate (setModulationSymbol)\n");
    }
    else if (type[0] == 5) // 32APSK
    {

        if (codeRate[0] == 3.f / 4) //	3/4
        {
            float temp_re[32] = { 0.381059441853851,0.139477436070429,0.381059441853851,0.139477436070428,-0.381059441853851,-0.139477436070429,-0.381059441853851,-0.139477436070429,0.923879532511287,0.382683432365090,0.707106781186547,-0.000000000000000,-0.707106781186547,0.000000000000000,-0.923879532511287,-0.382683432365090,0.520536877924280,0.134175859807694,0.520536877924280,0.134175859807694,-0.520536877924280,-0.134175859807694,-0.520536877924280,-0.134175859807694,1.000000000000000,0.707106781186548,0.923879532511287,0.382683432365090,-0.923879532511287,-0.382683432365090,-1.000000000000000,-0.707106781186548 };
            float temp_im[32] = { 0.381059441853851,0.520536877924280,-0.381059441853851,-0.520536877924280,0.381059441853851,0.520536877924280,-0.381059441853851,-0.520536877924280,0.382683432365090,0.923879532511287,-0.707106781186548,-1.000000000000000,0.707106781186548,1.000000000000000,-0.382683432365090,-0.923879532511287,0.139477436070429,0.134175859807694,-0.139477436070429,-0.134175859807694,0.139477436070429,0.134175859807694,-0.139477436070429,-0.134175859807694,0,0.707106781186547,-0.382683432365090,-0.923879532511287,0.382683432365090,0.923879532511287,0.000000000000000,-0.707106781186547 };
            //for (int i = 0; i < 32; i++)
            if (i < 32)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 4.f / 5) //	4/5
        {
            float temp_re[32] = { 0.394934382921439,   0.144556016977178,   0.394934382921439,   0.144556016977178,  -0.394934382921439,  -0.144556016977178,  -0.394934382921439,  -0.144556016977178,   0.923879532511287,   0.382683432365090,   0.707106781186547,  -0.000000000000000,  -0.707106781186547,   0.000000000000000,  -0.923879532511287,  -0.382683432365090,   0.539490399898617,   0.145196464309353,   0.539490399898617,   0.145196464309353,  -0.539490399898617,  -0.145196464309353,  -0.539490399898617,  -0.145196464309353,   1.000000000000000,   0.707106781186548,   0.923879532511287,   0.382683432365090,  -0.923879532511287,  -0.382683432365090,  -1.000000000000000,  -0.707106781186548 };
            float temp_im[32] = { 0.394934382921439,   0.539490399898617,  -0.394934382921439,  -0.539490399898617,   0.394934382921439,   0.539490399898617,  -0.394934382921439,  -0.539490399898617,   0.382683432365090,   0.923879532511287,  -0.707106781186548,  -1.000000000000000,   0.707106781186548,   1.000000000000000,  -0.382683432365090,  -0.923879532511287,   0.144556016977178,   0.145196464309353,  -0.144556016977178,  -0.145196464309353,   0.144556016977178,   0.145196464309353,  -0.144556016977178,  -0.145196464309353, 0,   0.707106781186547,  -0.382683432365090,  -0.923879532511287,   0.382683432365090,   0.923879532511287,   0.000000000000000,  -0.707106781186547 };
            //for (int i = 0; i < 32; i++)
            if (i < 32)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 5.f / 6) //	5/6
        {
            float temp_re[32] = { 0.402319375502691,   0.147259111868676,   0.402319375502691,   0.147259111868675,  -0.402319375502691,  -0.147259111868676,  -0.402319375502691,  -0.147259111868676,   0.923879532511287,   0.382683432365090,   0.707106781186547,  -0.000000000000000,  -0.707106781186547,   0.000000000000000,  -0.923879532511287,  -0.382683432365090,   0.549578487371366,   0.152393702841928,   0.549578487371366,   0.152393702841928,  -0.549578487371366,  -0.152393702841928,  -0.549578487371366,  -0.152393702841928,   1.000000000000000,   0.707106781186548,   0.923879532511287,   0.382683432365090,  -0.923879532511287,  -0.382683432365090,  -1.000000000000000,  -0.707106781186548 };
            float temp_im[32] = { 0.402319375502691,   0.549578487371366,  -0.402319375502691,  -0.549578487371366,   0.402319375502691,   0.549578487371366,  -0.402319375502691,  -0.549578487371366,   0.382683432365090,   0.923879532511287,  -0.707106781186548,  -1.000000000000000,   0.707106781186548,   1.000000000000000,  -0.382683432365090,  -0.923879532511287,   0.147259111868676,   0.152393702841928,  -0.147259111868676,  -0.152393702841928,   0.147259111868676,   0.152393702841928,  -0.147259111868676,  -0.152393702841928,   0,   0.707106781186547,  -0.382683432365090,  -0.923879532511287,   0.382683432365090,   0.923879532511287,   0.000000000000000,  -0.707106781186547 };
            //for (int i = 0; i < 32; i++)
            if (i < 32)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 8.f / 9) //	8/9
        {
            float temp_re[32] = { 0.414792430534372,   0.151824566873072,   0.414792430534372,   0.151824566873072,  -0.414792430534372,  -0.151824566873072,  -0.414792430534372,  -0.151824566873073,   0.923879532511287,   0.382683432365090,   0.707106781186547,  -0.000000000000000,  -0.707106781186547,   0.000000000000000,  -0.923879532511287,  -0.382683432365090,   0.566616997407444,   0.163304106509595,   0.566616997407444,   0.163304106509595,  -0.566616997407444,  -0.163304106509595,  -0.566616997407444,  -0.163304106509595,   1.000000000000000,   0.707106781186548,   0.923879532511287,   0.382683432365090,  -0.923879532511287,  -0.382683432365090,  -1.000000000000000,  -0.707106781186548 };
            float temp_im[32] = { 0.414792430534372,   0.566616997407444,  -0.414792430534372,  -0.566616997407444,   0.414792430534372,   0.566616997407444,  -0.414792430534372,  -0.566616997407444,   0.382683432365090,   0.923879532511287,  -0.707106781186548,  -1.000000000000000,   0.707106781186548,   1.000000000000000,  -0.382683432365090,  -0.923879532511287,   0.151824566873072,   0.163304106509595,  -0.151824566873073,  -0.163304106509595,   0.151824566873072,   0.163304106509595,  -0.151824566873072,  -0.163304106509595,                   0,   0.707106781186547,  -0.382683432365090,  -0.923879532511287,   0.382683432365090,   0.923879532511287,   0.000000000000000,  -0.707106781186547 };
            //for (int i = 0; i < 32; i++)
            if (i < 32)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else if (codeRate[0] == 9.f / 10) //	9/10
        {
            float temp_re[32] = { 0.416041896837666,   0.152281903281251,   0.416041896837666,   0.152281903281250,  -0.416041896837666,  -0.152281903281250,  -0.416041896837666,  -0.152281903281251,   0.923879532511287,   0.382683432365090,   0.707106781186547,  -0.000000000000000,  -0.707106781186547,   0.000000000000000,  -0.923879532511287,  -0.382683432365090,   0.568323800118917,   0.164443437485244,   0.568323800118917,   0.164443437485244,  -0.568323800118917,  -0.164443437485244,  -0.568323800118917,  -0.164443437485244,   1.000000000000000,   0.707106781186548,   0.923879532511287,   0.382683432365090,  -0.923879532511287,  -0.382683432365090,  -1.000000000000000,  -0.707106781186548 };
            float temp_im[32] = { 0.416041896837666,   0.568323800118917,  -0.416041896837666,  -0.568323800118917,   0.416041896837666,   0.568323800118917,  -0.416041896837666,  -0.568323800118917,   0.382683432365090,   0.923879532511287,  -0.707106781186548,  -1.000000000000000,   0.707106781186548,   1.000000000000000,  -0.382683432365090,  -0.923879532511287,   0.152281903281251,   0.164443437485244,  -0.152281903281251,  -0.164443437485244,   0.152281903281250,   0.164443437485244,  -0.152281903281251,  -0.164443437485244,                   0,   0.707106781186547,  -0.382683432365090,  -0.923879532511287,   0.382683432365090,   0.923879532511287,   0.000000000000000,  -0.707106781186547 };
            //for (int i = 0; i < 32; i++)
            if (i < 32)
            {
                modulation_symb_re[i] = temp_re[i];
                modulation_symb_im[i] = temp_im[i];
            }
        }
        else
            if(i == 0)
            printf("invalid codeRate (setModulationSymbol)\n");
    }
    else
        if(i == 0)
        printf("Invalid modOrder (setModulationSymbol)\n");
}

__global__
    void softDemapper(float* input_re, float* input_im,
                 float *output, int* type,
                 const float* modulation_symb_re, const float* modulation_symb_im,
                 int* frameLen)
{
    int i = threadIdx.x + blockDim.x * blockIdx.x;
    int j = blockIdx.y;
    float sigma2 = 0.03162*0.03162;
    /*if (i == 0)
    printf("type[0]: %i\n", type[0]);*/

    if (type[0] == 2) //QPSK
    {
        if (i < frameLen[0])
        {
            if (j < 2)
            {
                float num{ 0 };
                float den{ 0 };
                float minNumDist{ 1000 }, minDenDist{ 1000 };
                for (int k = 0; k < 2; k++)
                {
                    float tmp_re = input_re[i] - modulation_symb_re[dev_bit_2[j * 2 + k]];
                    float tmp_im = input_im[i] - modulation_symb_im[dev_bit_2[j * 2 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minNumDist)
                        minNumDist = tmp_re* tmp_re + tmp_im * tmp_im;

                    tmp_re = input_re[i] - modulation_symb_re[dev_bit_2[2 * 2 + j * 2 + k]];
                    tmp_im = input_im[i] - modulation_symb_im[dev_bit_2[2 * 2 + j * 2 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minDenDist)
                        minDenDist = tmp_re* tmp_re + tmp_im * tmp_im;
                }
                //if (threadIdx.x == 0 && blockIdx.x == 0)
                //	printf("den: %f \n", den);
                //output[2 * i + 1 - j] = log10f(num / den);
                output[2 * i + 1 - j] = 1 / (sigma2*31.8) * (minNumDist - minDenDist);
            }
            //i += blockDim.x;
        }
    }
    else if (type[0] == 3) //8PSK
    {
        if (i < frameLen[0])
        {
            if (j < 3)
            {
                float num{ 0 };
                float den{ 0 };
                float minNumDist{ 1000 }, minDenDist{ 1000 };
                float tmp_re, tmp_im;
                for (int k = 0; k < 4; k++)
                {
                    tmp_re = input_re[i] - modulation_symb_re[dev_bit_3[j * 4 + k]];
                    tmp_im = input_im[i] - modulation_symb_im[dev_bit_3[j * 4 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minNumDist)
                        minNumDist = tmp_re* tmp_re + tmp_im * tmp_im;

                    tmp_re = input_re[i] - modulation_symb_re[dev_bit_3[3 * 4 + j * 4 + k]];
                    tmp_im = input_im[i] - modulation_symb_im[dev_bit_3[3 * 4 + j * 4 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minDenDist)
                        minDenDist = tmp_re* tmp_re + tmp_im * tmp_im;
                }
                /*if (i == 0 || i == 1)
                printf("num= %f, den= %f, i= %i\n", num, den, i);*/
                output[3 * i + 2 - j] = 1 / (sigma2*31.8) * (minNumDist - minDenDist);
            }
            //i += blockDim.x;
        }
    }
    else if (type[0] == 4) //16APSK
    {
        if (i < frameLen[0])
        {
            if (j < 4)
            {
                float num{ 0 };
                float den{ 0 };
                float minNumDist{ 1000 }, minDenDist{ 1000 };
                for (int k = 0; k < 8; k++)
                {
                    float tmp_re = input_re[i] - modulation_symb_re[dev_bit_4[j * 8 + k]];
                    float tmp_im = input_im[i] - modulation_symb_im[dev_bit_4[j * 8 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minNumDist)
                        minNumDist = tmp_re* tmp_re + tmp_im * tmp_im;

                    tmp_re = input_re[i] - modulation_symb_re[dev_bit_4[4 * 8 + j * 8 + k]];
                    tmp_im = input_im[i] - modulation_symb_im[dev_bit_4[4 * 8 + j * 8 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minDenDist)
                        minDenDist = tmp_re* tmp_re + tmp_im * tmp_im;
                }
                /*if (threadIdx.x == 0)
                printf("num = %e , den = %e ,i = %i, j = %i\n", num, den, i, j);*/

                output[4 * i + 3 - j] = 1 / (sigma2*31.8) * (minNumDist - minDenDist);
            }
            //i += blockDim.x;
        }
    }
    else if (type[0] == 5) //32APSK
    {
        if (i < frameLen[0])
        {
            if (j < 5)
            {
                float num{ 0 };
                float den{ 0 };
                float minNumDist{ 1000 }, minDenDist{ 1000 };
                for (int k = 0; k < 16; k++)
                {
                    float tmp_re = input_re[i] - modulation_symb_re[dev_bit_5[j * 16 + k]];
                    float tmp_im = input_im[i] - modulation_symb_im[dev_bit_5[j * 16 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minNumDist)
                        minNumDist = tmp_re* tmp_re + tmp_im * tmp_im;

                    tmp_re = input_re[i] - modulation_symb_re[dev_bit_5[5 * 16 + j * 16 + k]];
                    tmp_im = input_im[i] - modulation_symb_im[dev_bit_5[5 * 16 + j * 16 + k]];
                    if (tmp_re* tmp_re + tmp_im * tmp_im < minDenDist)
                        minDenDist = tmp_re* tmp_re + tmp_im * tmp_im;
                }

                output[5 * i + 4 - j] = 1 / (sigma2*31.8) * (minNumDist - minDenDist);
            }
            //i += blockDim.x;
        }
    }
    else
        if(blockIdx.x == 0 && blockIdx.y == 0 && threadIdx.x == 0)
        printf("Invalid modOrder (softDemapper)\n");
}
